"""
Python Memory Model - 파이썬이 변수들의 메모리 공간을 관리하는 방법
# PC에서 하는 모든 것은 메모리를 OS (i.e. windows 10, linux, mac OS) 로 부터 할당받는다 -> RAM (한계)
# 한번에 여러개의 프로그램들이 실행된다 (유튜브로 노래들으면서 페이스북 띄어놓고 파이참으로 코딩짜버리기ㅣㅣㅣㅣ)
# 파이썬도 많은 프로그램 중 하나
# 여기서 말하는 메모리란 RAM 전체가 아니라 OS에서 파이썬에게 할당받은 영역의 메모리
# .copy 를 무엇인가
"""

n1 =1
print(f'주소 = {id(n1)}, 저장된 값 = {n1}')
# 파이썬은 1을 만들어 내야한다
# 물이라는 실체가 있어야한다, 이 실체를 프로그램에서 object(객체) 라고 부른다
# 1 이라는 객체를 n1이라는 변수(컵)을 저장하겠다
# n1은 1이라는 객체가 아니라, 1 이 어디있는지 찾아갈 수 있는 주소값을 가지고 있는 것
# 그래서 우리는 변수가 객체를 찾아가는 것을 reference 한다라고 표현

n2 = n1
# n2 와 n1의 주소값이 같다
print(f'주소 = {id(n2)}, 저장된 값 = {n2}')

n2 = 2
print(f'주소 = {id(n2)}, 저장된 값 = {n2}')
# 주소값이 바뀌었어요
# 2라고 하는 새로운 객체가 생겼고, heap에도 새로운 객체가 생성되었다
# 새로운 주소로 찾아가는 것

# 새로운 객체가 만들어 질 때 마다, heap 에 새로운 공간들이 만들어진다

n3 = 1
print(f'주소 = {id(n3)}, 저장된 값 = {n3}')
# 값이 같은 변수, n1 의 주소와 같다
# 새로운 공간이 프레임에 생성되었지만, heap 에 새로운 걸 생성하지 않고, 원래 객체에 돌아간다
# 파이썬은 스스로 객체를 관리하고, 원래 n1 에 1 이라는 객체가 있다는 걸 아니까
# 그리고 같은 객체를 계속 만들면 메모리도 많이 잡아먹으니까,,,
# 정수와 문자열인 경우에 같은 숫자/문자열을 저장하는 새로운 변수를 선언하면 cached them
# when a variable has the same object(numeric or char), cache them (reuse)

n3 = 3 -1
print(f'주소 = {id(n3)}, 저장된 값 = {n3}')
# n2 =2 와 같은 주소를 공유한다
# 위와 같은 logic
# 정수와 문자열은 아랫쪽에서 재활용해서 계속 사용하게 된다
# 나머지 아이들은 새로운 객체가 생길 때 마다 새로운게 생긴다

# 숫자,문자열을 제외한 다른 모든 객체들은 값이 사용할 대 마다 새로 생성된다
# f for float
f1 = 1.2
print(f'주소 = {id(f1)}, 저장된 값 = {f1}')
f2 = 1.2
print(f'주소 = {id(f2)}, 저장된 값 = {f2}')
# 정수는 다시 돌려도 id값이 같지만 float은 바뀐다

# string
s1 = 'abc'
print(f'add = {id(s1)}, saved_char = {s1}')
s2 = 'abc'
print(f'add = {id(s2)}, saved_val = {s2}')


#list
list1 = [1,2,3]
print(f'add = {id(list1)}, saved_char = {list1}')
list2 = [1,2,3] #기존 리스트를 재활용하지 않고, 새로운 리스트만 생성한다
print(f'add = {id(list2)}, saved_val = {list2}')
# same contents, but they have diff. add returned
list2[0] = 100
print(f'new_list2 = {list2}')
list3 = list2
print(f'add = {id(list3)}, saved_val = {list3}')
# 하지만 list3 & list2 have same add

# 이 차이가 굉장히 많은 차이가 생긴다, list2의 첫번째 인덱스를 100으로 바꾸어도 다른 리스트들은 영향을 받지 않는다
# 리스트 2번만 바뀌어 있는다
# 하지만 list3 = list2 로 바꾸어서 보면, list3의 값도 바뀌어 있다 왜냐하면 주소값이 같으니까

list3[1] = 200
print(list2, list3)
# 두 리스트가 같다

# 그래서 .copy는?
# 함수는 누군가가 자신을 불러줬을 때 실행된다 (어린왕자가 생각나는군)

# == 연산자 vs is 연산자 차이점
# 두 연산자는 같은게 아니다, 혼동사용 노노
a = [1,2,3]
b = [1,2,3]

print(f'==: {a == b}, is: {a is b}')
# == : True, is : False
# is 함부러 쓰면 안된다
# == 은 실제 값들은 비교해서 같은지 다른지를 준다, 하지만 is는 a와 b의 주소를 비교해서 값을 준다
# 숫자와 문자열을 비교하면 is 를 같은 값은 준다, 값이 같으면 주소가 같으니까
# == 연산자: 두 변수가 참조하는 객체의 값이 같은지 비교
# is 연산자: 두 변수에 저장된 주소를 비교

